import { openai, isOpenAIConfigured } from '../lib/openai';
import { CATEGORIES, type Category } from '../types';

export interface AutoCategorizeResult {
  category: Category;
  confidence: number;
  reasoning: string;
}

export interface AutoTagResult {
  tags: string[];
  reasoning: string;
}

export interface QualityScoreResult {
  score: number;
  feedback: string;
  suggestions: string[];
}

export interface EmbeddingResult {
  embedding: number[];
}

/**
 * Analyzes prompt text and suggests the most appropriate category
 */
export async function autoCategorize(promptText: string, title: string): Promise<AutoCategorizeResult> {
  if (!isOpenAIConfigured || !openai) {
    throw new Error('OpenAI API is not configured');
  }

  const systemPrompt = `You are an AI assistant that categorizes prompts.
Available categories: ${CATEGORIES.join(', ')}.
Analyze the prompt and determine the most appropriate category.
Return a JSON object with: category (one of the available categories), confidence (0-1), and reasoning (brief explanation).`;

  const userPrompt = `Title: ${title}\n\nPrompt: ${promptText}`;

  const response = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ],
    response_format: { type: 'json_object' },
    temperature: 0.3,
  });

  const result = JSON.parse(response.choices[0].message.content || '{}');

  // Validate category
  if (!CATEGORIES.includes(result.category)) {
    result.category = 'Other';
  }

  return {
    category: result.category as Category,
    confidence: result.confidence || 0.5,
    reasoning: result.reasoning || 'Category suggested by AI'
  };
}

/**
 * Generates relevant tags for a prompt
 */
export async function autoTag(promptText: string, title: string): Promise<AutoTagResult> {
  if (!isOpenAIConfigured || !openai) {
    throw new Error('OpenAI API is not configured');
  }

  const systemPrompt = `You are an AI assistant that generates relevant tags for prompts.
Generate 3-7 descriptive tags that capture the key themes, use cases, and characteristics of the prompt.
Tags should be concise (1-2 words), lowercase, and highly relevant.
Return a JSON object with: tags (array of strings) and reasoning (brief explanation).`;

  const userPrompt = `Title: ${title}\n\nPrompt: ${promptText}`;

  const response = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ],
    response_format: { type: 'json_object' },
    temperature: 0.5,
  });

  const result = JSON.parse(response.choices[0].message.content || '{}');

  return {
    tags: result.tags || [],
    reasoning: result.reasoning || 'Tags generated by AI'
  };
}

/**
 * Scores the quality of a prompt (0-100)
 */
export async function scoreQuality(promptText: string, title: string): Promise<QualityScoreResult> {
  if (!isOpenAIConfigured || !openai) {
    throw new Error('OpenAI API is not configured');
  }

  const systemPrompt = `You are an AI assistant that evaluates prompt quality.
Assess the prompt based on:
- Clarity and specificity
- Structure and formatting
- Completeness of instructions
- Potential effectiveness
- Context provided

Return a JSON object with:
- score (0-100, integer)
- feedback (brief summary of quality)
- suggestions (array of 2-4 specific improvement suggestions)`;

  const userPrompt = `Title: ${title}\n\nPrompt: ${promptText}`;

  const response = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ],
    response_format: { type: 'json_object' },
    temperature: 0.3,
  });

  const result = JSON.parse(response.choices[0].message.content || '{}');

  return {
    score: Math.min(100, Math.max(0, result.score || 50)),
    feedback: result.feedback || 'Quality assessment completed',
    suggestions: result.suggestions || []
  };
}

/**
 * Generates embeddings for semantic search
 */
export async function generateEmbedding(text: string): Promise<EmbeddingResult> {
  if (!isOpenAIConfigured || !openai) {
    throw new Error('OpenAI API is not configured');
  }

  const response = await openai.embeddings.create({
    model: 'text-embedding-3-small',
    input: text,
  });

  return {
    embedding: response.data[0].embedding
  };
}

/**
 * Batch process AI features for a prompt
 */
export async function processPromptWithAI(
  promptText: string,
  title: string,
  options: {
    autoCategorize?: boolean;
    autoTag?: boolean;
    scoreQuality?: boolean;
    generateEmbedding?: boolean;
  }
) {
  const results: {
    category?: AutoCategorizeResult;
    tags?: AutoTagResult;
    quality?: QualityScoreResult;
    embedding?: EmbeddingResult;
  } = {};

  const promises = [];

  if (options.autoCategorize) {
    promises.push(
      autoCategorize(promptText, title)
        .then(result => { results.category = result; })
        .catch(err => console.error('Auto-categorize failed:', err))
    );
  }

  if (options.autoTag) {
    promises.push(
      autoTag(promptText, title)
        .then(result => { results.tags = result; })
        .catch(err => console.error('Auto-tag failed:', err))
    );
  }

  if (options.scoreQuality) {
    promises.push(
      scoreQuality(promptText, title)
        .then(result => { results.quality = result; })
        .catch(err => console.error('Quality scoring failed:', err))
    );
  }

  if (options.generateEmbedding) {
    promises.push(
      generateEmbedding(`${title} ${promptText}`)
        .then(result => { results.embedding = result; })
        .catch(err => console.error('Embedding generation failed:', err))
    );
  }

  await Promise.all(promises);

  return results;
}
