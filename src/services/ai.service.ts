import { openai, isOpenAIConfigured } from '../lib/openai';
import { CATEGORIES, type Category } from '../types';

export interface AutoCategorizeResult {
  category: Category;
  confidence: number;
  reasoning: string;
}

export interface AutoTagResult {
  tags: string[];
  reasoning: string;
}

export interface QualityScoreResult {
  score: number;
  feedback: string;
  suggestions: string[];
}

export interface EmbeddingResult {
  embedding: number[];
}

/**
 * Analyzes prompt text and suggests the most appropriate category
 */
export async function autoCategorize(promptText: string, title: string): Promise<AutoCategorizeResult> {
  if (!isOpenAIConfigured || !openai) {
    throw new Error('OpenAI API is not configured');
  }

  const systemPrompt = `You are an AI assistant that categorizes prompts.
Available categories: ${CATEGORIES.join(', ')}.
Analyze the prompt and determine the most appropriate category.
Return a JSON object with: category (one of the available categories), confidence (0-1), and reasoning (brief explanation).`;

  const userPrompt = `Title: ${title}\n\nPrompt: ${promptText}`;

  const response = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ],
    response_format: { type: 'json_object' },
    temperature: 0.3,
  });

  const result = JSON.parse(response.choices[0].message.content || '{}');

  // Validate category
  if (!CATEGORIES.includes(result.category)) {
    result.category = 'Other';
  }

  return {
    category: result.category as Category,
    confidence: result.confidence || 0.5,
    reasoning: result.reasoning || 'Category suggested by AI'
  };
}

/**
 * Generates relevant tags for a prompt
 */
export async function autoTag(promptText: string, title: string): Promise<AutoTagResult> {
  if (!isOpenAIConfigured || !openai) {
    throw new Error('OpenAI API is not configured');
  }

  const systemPrompt = `You are an AI assistant that generates relevant tags for prompts.
Generate 3-7 descriptive tags that capture the key themes, use cases, and characteristics of the prompt.
Tags should be concise (1-2 words), lowercase, and highly relevant.
Return a JSON object with: tags (array of strings) and reasoning (brief explanation).`;

  const userPrompt = `Title: ${title}\n\nPrompt: ${promptText}`;

  const response = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ],
    response_format: { type: 'json_object' },
    temperature: 0.5,
  });

  const result = JSON.parse(response.choices[0].message.content || '{}');

  return {
    tags: result.tags || [],
    reasoning: result.reasoning || 'Tags generated by AI'
  };
}

/**
 * Scores the quality of a prompt (0-100)
 */
export async function scoreQuality(promptText: string, title: string): Promise<QualityScoreResult> {
  if (!isOpenAIConfigured || !openai) {
    throw new Error('OpenAI API is not configured');
  }

  const systemPrompt = `You are an AI assistant that evaluates prompt quality.
Assess the prompt based on:
- Clarity and specificity
- Structure and formatting
- Completeness of instructions
- Potential effectiveness
- Context provided

Return a JSON object with:
- score (0-100, integer)
- feedback (brief summary of quality)
- suggestions (array of 2-4 specific improvement suggestions)`;

  const userPrompt = `Title: ${title}\n\nPrompt: ${promptText}`;

  const response = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ],
    response_format: { type: 'json_object' },
    temperature: 0.3,
  });

  const result = JSON.parse(response.choices[0].message.content || '{}');

  return {
    score: Math.min(100, Math.max(0, result.score || 50)),
    feedback: result.feedback || 'Quality assessment completed',
    suggestions: result.suggestions || []
  };
}

/**
 * Generates embeddings for semantic search
 */
export async function generateEmbedding(text: string): Promise<EmbeddingResult> {
  if (!isOpenAIConfigured || !openai) {
    throw new Error('OpenAI API is not configured');
  }

  const response = await openai.embeddings.create({
    model: 'text-embedding-3-small',
    input: text,
  });

  return {
    embedding: response.data[0].embedding
  };
}

/**
 * Batch process AI features for a prompt
 */
export async function processPromptWithAI(
  promptText: string,
  title: string,
  options: {
    autoCategorize?: boolean;
    autoTag?: boolean;
    scoreQuality?: boolean;
    generateEmbedding?: boolean;
  }
) {
  const results: {
    category?: AutoCategorizeResult;
    tags?: AutoTagResult;
    quality?: QualityScoreResult;
    embedding?: EmbeddingResult;
  } = {};

  const promises = [];

  if (options.autoCategorize) {
    promises.push(
      autoCategorize(promptText, title)
        .then(result => { results.category = result; })
        .catch(err => console.error('Auto-categorize failed:', err))
    );
  }

  if (options.autoTag) {
    promises.push(
      autoTag(promptText, title)
        .then(result => { results.tags = result; })
        .catch(err => console.error('Auto-tag failed:', err))
    );
  }

  if (options.scoreQuality) {
    promises.push(
      scoreQuality(promptText, title)
        .then(result => { results.quality = result; })
        .catch(err => console.error('Quality scoring failed:', err))
    );
  }

  if (options.generateEmbedding) {
    promises.push(
      generateEmbedding(`${title} ${promptText}`)
        .then(result => { results.embedding = result; })
        .catch(err => console.error('Embedding generation failed:', err))
    );
  }

  await Promise.all(promises);

  return results;
}

/**
 * Improves a prompt using AI
 */
export async function improvePrompt(promptText: string): Promise<{
  improved_prompt: string;
  changes_made: string[];
  reasoning: string;
  clarity_score: number;
  specificity_score: number;
  structure_score: number;
  overall_score: number;
}> {
  if (!isOpenAIConfigured || !openai) {
    throw new Error('OpenAI API is not configured');
  }

  const systemPrompt = `You are an expert prompt engineer. Your job is to analyze and improve AI prompts to make them more effective.

When improving a prompt, focus on these key areas:

1. **Clarity**: Remove ambiguity, fix grammar, clarify instructions
2. **Structure**: Add clear sections (Context, Task, Format, Constraints)
3. **Specificity**: Add concrete details, examples, and parameters
4. **Format**: Specify exact output format needed
5. **Context**: Add relevant background information
6. **Examples**: Include few-shot examples when helpful

Guidelines:
- Keep the user's intent unchanged
- Make improvements actionable and clear
- Explain your changes in simple terms
- Don't over-complicate simple prompts
- Preserve the tone unless it's unclear

Return your response as a JSON object with:
{
  "improved_prompt": "The enhanced prompt text",
  "changes_made": ["List of 3-5 specific improvements"],
  "reasoning": "Brief 1-2 sentence explanation of the main changes",
  "clarity_score": 0.85,
  "specificity_score": 0.90,
  "structure_score": 0.80,
  "overall_score": 0.85
}

Scores should be between 0.0 and 1.0, where 1.0 is perfect.`;

  const response = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: `Improve this prompt:\n\n${promptText}` }
    ],
    response_format: { type: 'json_object' },
    temperature: 0.3,
  });

  const result = JSON.parse(response.choices[0].message.content || '{}');

  return {
    improved_prompt: result.improved_prompt || promptText,
    changes_made: result.changes_made || [],
    reasoning: result.reasoning || 'Prompt improved',
    clarity_score: result.clarity_score || 0.5,
    specificity_score: result.specificity_score || 0.5,
    structure_score: result.structure_score || 0.5,
    overall_score: result.overall_score || 0.5
  };
}
